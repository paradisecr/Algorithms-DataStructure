# 数据结构之 ——排序    


1. 冒泡排序
- BubbleSort
- 时间复杂度O(n方)
- 稳定
2. 插入排序  
(1)直接插入排序  
- InsertSort
- 时间复杂度O(n方)
- 稳定
- [0,i)是有序区，每一趟将a[i]插入有序区合适位置，使得[0,i]有序。  

(2)折半插入
- BinaryInsertSort
- 时间复杂度：O(nlogn)
- 稳定
- 直接插入排序的改进，将寻找插入位置的方式改为二分查找，将查找速度由n加速到了logn。  

(3)希尔排序
- ShellSort
- 时间复杂度O(n^1.25 - 1.6n^1.25)
- 不稳定
- 按照一定间隔进行排序，然后不断缩短间隔，最终使得有序。gap可取(gap/3)+1向下取整。由于对于即使规模较大的序列(n<=1000)
，希尔排序都具有较高的效率。并且希尔排序算法简单，容易执行，所以很多应用程序都选用了此排序算法。

3. 快速排序  
(1)快速排序
- QuickSort
- 时间复杂度O(nlogn)-O(n方)
- 不稳定
- 采用分治法，基本思想是任取一个元素作为基准，将序列划分为子序列，使得基准元素左侧的元素都小于基准、右侧都大于等于基准。
再分别对自序列迭代实行上述划分，最终使得有序。快速排序是目前应用最广泛的排序算法，运行速度快。  

(2)快速排序的改进1
- QuickInsertSort1
- 当序列长度M取值为5-25时，采用直接插入排序要比快速排序至少快10%，在快速排序过程中，当子序列规模较小时，直接调用插入排序。

(3)快速排序的改进2
- QuickInsertSort2
- 对于初始排列已经基本有序的序列，直接插入排序算法具有很高的效率； 对于长度小于M的子序列，不再partition。
而是再最后整体执行一遍直接插入排序  

4. 选择排序  
(1) 直接选择排序  
- SelectSort
- 时间复杂度O(n方)
- 不稳定
- [0,i)为有序，从[i,length]中选取最小元素，与i对调。 待排序序列的有序性对选择排序的运行时间影响不大。
因为从未排序序列选择最小元素的过程中，没有对下一趟找到最小项的位置给出相关信息。  

5. 归并排序
- MergeSort
- 时间复杂度O(nlogn)
- 稳定
- 分治法：划分-归并。先划分，在归并过程中排序。

6. 堆排序 //TODO 
