# 数据结构之 ——排序    


1. 冒泡排序

- BubbleSort
- 时间复杂度O(n方)
- 稳定
2. 插入排序  

(1)直接插入排序  
- InsertSort
- 时间复杂度O(n方)
- 稳定
- [0,i)是有序区，每一趟将a[i]插入有序区合适位置，使得[0,i]有序。  
- 对于规模很小的序列(n<=25)非常有效，时间复杂度与元素的初始序列有关。

(2)折半插入

- BinaryInsertSort
- 时间复杂度：O(nlogn)
- 稳定
- 直接插入排序的改进，将寻找插入位置的方式改为二分查找，将查找速度由n加速到了logn。  

(3)希尔排序

- ShellSort
- 时间复杂度O(n^1.25 - 1.6n^1.25)
- 不稳定
- 按照一定间隔进行排序，然后不断缩短间隔，最终使得有序。gap可取(gap/3)+1向下取整。由于对于即使规模较大的序列(n<=1000)
，希尔排序都具有较高的效率。并且希尔排序算法简单，容易执行，所以很多应用程序都选用了此排序算法。

3. 快速排序  

(1)快速排序
- QuickSort
- 时间复杂度O(nlogn)-O(n方)
- 不稳定：元素交换可能会打乱顺序。
- 采用分治法，基本思想是任取一个元素作为基准，将序列划分为子序列，使得基准元素左侧的元素都小于基准、右侧都大于等于基准。
再分别对自序列迭代实行上述划分，最终使得有序。快速排序是目前应用最广泛的排序算法，运行速度快。  

(2)快速排序的改进1
- QuickInsertSort1
- 当序列长度M取值为5-25时，采用直接插入排序要比快速排序至少快10%，在快速排序过程中，当子序列规模较小时，直接调用插入排序。

(3)快速排序的改进2
- QuickInsertSort2
- 对于初始排列已经基本有序的序列，直接插入排序算法具有很高的效率； 对于长度小于M的子序列，不再partition。
而是再最后整体执行一遍直接插入排序  

4. 选择排序  

(1) 直接选择排序  
- SelectSort
- 时间复杂度总是O(n方)
- 不稳定：交换元素时会打乱顺序。
- [0,i)为有序，从[i,length]中选取最小元素，与i对调。 待排序序列的有序性对选择排序的运行时间影响不大。
因为从未排序序列选择最小元素的过程中，没有对下一趟找到最小项的位置给出相关信息。  

5. 归并排序

- MergeSort
- 时间复杂度O(nlogn)
- 稳定
- 分治法：划分-归并。先划分，在归并过程中排序。

6. 堆排序 

- HeapSort
- 时间复杂度O(nlogn)
- 不稳定
- 先构成最大堆，然后每次选择堆顶元素。

7. 桶排序

- 实现// TODO
- 平均时间啊复杂度O(n)
- 假设输入数据服从均匀分布，划分均匀的区间为桶，桶内再进行排序。

8. 基数排序  
 
- 每个元素的排序码都是由多个排序码做成的组项。分为：
    - 最高位优先(Most Significant Digit first, MSD);
    - 最低位优先(Least Significant Digit first, LSD)。

(1) MSD基数排序
- MSDSort

(2) LSD基数排序 
- O(d(n + radix)):n分配、radix收集


## 总结：

- 稳定排序：冒泡排序、直接插入排序、归并排序
- 不稳定排序： Shell排序、直接选择排序、快速排序、堆排序
- 基本排序：直接插入、直接选择、冒泡排序。适合n<10K的情形。
- 快速排序、堆排序、归并排序适合元素个数n很大的情况。